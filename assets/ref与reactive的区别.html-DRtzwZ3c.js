import{_ as s,c as n,o as a,a as e}from"./app-90N25QkG.js";const t={},p=e(`<h1 id="ref-和-reactive-区别" tabindex="-1"><a class="header-anchor" href="#ref-和-reactive-区别"><span>ref 和 reactive 区别</span></a></h1><p>ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</p><p>template 模板中使用的数据和方法，都需要通过 setup 函数 return 出去才可以被使用。 ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。而reactive则不需要</p><p>ref 函数可以接收原始数据类型与引用数据类型。 reactive 函数只能接收引用数据类型。 ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</p><p>reactive 和 ref 都是用来定义响应式数据的 reactive更推荐去定义复杂的数据类型 ref 更推荐定义基本类型</p><p>ref与reactive 是 Vue3 新推出的主要 API 之一，它们主要用于响应式数据的创建。</p><p>template 模板中使用的数据和方法，都需要通过 setup 函数 return 出去才可以被使用。 ref 函数创建的响应式数据，在模板中可以直接被使用，在 JS 中需要通过 .value 的形式才能使用。而reactive则不需要</p><p>ref 函数可以接收原始数据类型与引用数据类型。 reactive 函数只能接收引用数据类型。 ref 底层还是使用 reactive 来做，ref 是在 reactive 上在进行了封装，增强了其能力，使它支持了对原始数据类型的处理。 在 Vue3 中 reactive 能做的，ref 也能做，reactive 不能做的，ref 也能做。</p><p>reactive 和 ref 都是用来定义响应式数据的 reactive更推荐去定义复杂的数据类型 ref 更推荐定义基本类型</p><h1 id="为什么同样是赋值对象ref不会失去响应而reactive会" tabindex="-1"><a class="header-anchor" href="#为什么同样是赋值对象ref不会失去响应而reactive会"><span>为什么同样是赋值对象ref不会失去响应而reactive会?</span></a></h1><blockquote><p>ref 定义的数据（包括对象）时，返回的对象是一个包装过的简单值，而不是原始值的引用; 就和对象深拷贝一样,是将对象属性值的赋值 reactive定义数据（必须是对象），reactive返回的对象是对原始对象的引用，而不是简单值的包装。</p><p>类似对象的浅拷贝,是保存对象的栈地址,无论值怎么变还是指向原来的对象的堆地址; reactive就算赋值一个新的对象,reactive还是指向原来对象堆地址</p></blockquote><h2 id="拓展" tabindex="-1"><a class="header-anchor" href="#拓展"><span>拓展</span></a></h2><p>为什么推荐使用ref而不是reactive</p><p>reactive本身具有很大局限性导致使用过程需要额外注意,如果忽视这些问题将对开发造成不小的麻烦;ref更像是vue2时代option api的data的替代,可以存放任何数据类型,而reactive声明的数据类型只能是对象;</p><p>先抛出结论,再详细说原因:非必要不用reactive! (官方文档也有对应的推荐)</p><ol><li>给reactive赋一整个普通对象/reactive对象</li></ol><p>通常在页面数据回显时,需要将AJAX请求获取的对象直接赋值给响应式对象,如果操作不当就导致reactive声明的对象失去响应</p><p>赋值一个普通对象</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//这个赋值将导致state失去响应</span></span>
<span class="line">state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>赋值一个reactive对象</p><p>如果给reactive的响应式对象赋值普通对象会失去响应,那么给它赋值一个reactive的响应式对象不就行了吗?下面试试看</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token operator">&lt;</span>template<span class="token operator">&gt;</span></span>
<span class="line">  <span class="token punctuation">{</span><span class="token punctuation">{</span>state<span class="token punctuation">}</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>template<span class="token operator">&gt;</span>    </span>
<span class="line">​</span>
<span class="line"><span class="token operator">&lt;</span>stcirpt setup<span class="token operator">&gt;</span></span>
<span class="line"><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"> <span class="token comment">//nextTick异步方法中修改state的值</span></span>
<span class="line"><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">//并不会触发修改DOM  ,说明失去响应了</span></span>
<span class="line">  state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">11</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token operator">&lt;</span><span class="token operator">/</span>stcirpt<span class="token operator">&gt;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在nexTick中给state赋值一个reactive的响应式对象,但是DOM并没有更新! 解决方法:</p><p>不要直接整个对象替换,对象属性一个个赋值</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//state={count:1}</span></span>
<span class="line">state<span class="token punctuation">.</span>conut <span class="token operator">=</span> <span class="token number">1</span> </span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用Object.assign</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">// state =  {count:1}   state失去响应</span></span>
<span class="line">state <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>state <span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用ref定义对象</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">ref</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">state<span class="token punctuation">.</span>value<span class="token operator">=</span><span class="token punctuation">{</span><span class="token literal-property property">count</span><span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>3.直接reactive对象解构时</p><p>直接解构会失去响应</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">let</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//普通解构count 和 state.count 失去了响应性连接</span></span>
<span class="line"><span class="token keyword">let</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> state </span>
<span class="line">count<span class="token operator">++</span> <span class="token comment">// state.count值依旧是0</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解决方案:</p><p>使用toRefs解构不会失去响应</p><p>使用toRefs解构后的属性是ref的响应式数据</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token function">reactive</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">count</span><span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token comment">//使用toRefs解构,后的属性为ref的响应式变量</span></span>
<span class="line"><span class="token keyword">let</span> <span class="token punctuation">{</span> count <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">toRefs</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span></span>
<span class="line">count<span class="token punctuation">.</span>value<span class="token operator">++</span> <span class="token comment">// state.count值改变为1</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,36),c=[p];function l(o,i){return a(),n("div",null,c)}const u=s(t,[["render",l],["__file","ref与reactive的区别.html.vue"]]),d=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue3%E7%AF%87/ref%E4%B8%8Ereactive%E7%9A%84%E5%8C%BA%E5%88%AB.html","title":"ref 和 reactive 区别","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"拓展","slug":"拓展","link":"#拓展","children":[]}],"git":{"updatedTime":1724247277000,"contributors":[{"name":"前端架构师","email":"62106726+qdleader@users.noreply.github.com","commits":1}]},"filePathRelative":"前端面试/vue3篇/ref与reactive的区别.md"}');export{u as comp,d as data};
