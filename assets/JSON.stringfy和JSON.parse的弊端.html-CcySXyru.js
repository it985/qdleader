import{_ as n,c as s,o as a,a as e}from"./app-90N25QkG.js";const t={},o=e(`<h1 id="json-stringfy和json-parse的弊端" tabindex="-1"><a class="header-anchor" href="#json-stringfy和json-parse的弊端"><span>JSON.stringfy和JSON.parse的弊端</span></a></h1><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h2><h3 id="_1-如果obj里面有时间对象-则json-stringify后再json-parse的结果-时间将只是字符串的形式-而不是对象的形式" tabindex="-1"><a class="header-anchor" href="#_1-如果obj里面有时间对象-则json-stringify后再json-parse的结果-时间将只是字符串的形式-而不是对象的形式"><span>1.如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式</span></a></h3><h3 id="_2-如果obj里有函数-undefined-则序列化的结果会把函数或-undefined丢失" tabindex="-1"><a class="header-anchor" href="#_2-如果obj里有函数-undefined-则序列化的结果会把函数或-undefined丢失"><span>2.如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</span></a></h3><h3 id="_3-如果被拷贝的对象中有正则表达式-则拷贝之后的对象正则表达式会变成object" tabindex="-1"><a class="header-anchor" href="#_3-如果被拷贝的对象中有正则表达式-则拷贝之后的对象正则表达式会变成object"><span>3.如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object</span></a></h3><h3 id="_4、json-stringify-只能序列化对象的可枚举的自有属性-例如-如果obj中的对象是有构造函数生成的-则使用json-parse-json-stringify-obj-深拷贝后-会丢弃对象的constructor-会抛弃对象的constructor-所有的构造函数会指向object" tabindex="-1"><a class="header-anchor" href="#_4、json-stringify-只能序列化对象的可枚举的自有属性-例如-如果obj中的对象是有构造函数生成的-则使用json-parse-json-stringify-obj-深拷贝后-会丢弃对象的constructor-会抛弃对象的constructor-所有的构造函数会指向object"><span>4、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor； 会抛弃对象的constructor,所有的构造函数会指向Object</span></a></h3><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token function-variable function">eg</span><span class="token operator">:</span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span></span>
<span class="line">    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">const</span> liai <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">&#39;liai&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">const</span> test <span class="token operator">=</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&#39;a&#39;</span><span class="token punctuation">,</span></span>
<span class="line">    <span class="token literal-property property">date</span><span class="token operator">:</span> liai<span class="token punctuation">,</span></span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// debugger</span></span>
<span class="line">  <span class="token keyword">const</span> copyed <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  test<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;test&#39;</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">&#39;ddd&#39;</span><span class="token punctuation">,</span> test<span class="token punctuation">,</span> copyed<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,7),p=[o];function i(c,l){return a(),s("div",null,p)}const u=n(t,[["render",i],["__file","JSON.stringfy和JSON.parse的弊端.html.vue"]]),d=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/js%E7%B1%BB/%E5%85%B6%E4%BB%96%E7%B1%BB/JSON.stringfy%E5%92%8CJSON.parse%E7%9A%84%E5%BC%8A%E7%AB%AF.html","title":"JSON.stringfy和JSON.parse的弊端","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"缺点","slug":"缺点","link":"#缺点","children":[{"level":3,"title":"1.如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式","slug":"_1-如果obj里面有时间对象-则json-stringify后再json-parse的结果-时间将只是字符串的形式-而不是对象的形式","link":"#_1-如果obj里面有时间对象-则json-stringify后再json-parse的结果-时间将只是字符串的形式-而不是对象的形式","children":[]},{"level":3,"title":"2.如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；","slug":"_2-如果obj里有函数-undefined-则序列化的结果会把函数或-undefined丢失","link":"#_2-如果obj里有函数-undefined-则序列化的结果会把函数或-undefined丢失","children":[]},{"level":3,"title":"3.如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object","slug":"_3-如果被拷贝的对象中有正则表达式-则拷贝之后的对象正则表达式会变成object","link":"#_3-如果被拷贝的对象中有正则表达式-则拷贝之后的对象正则表达式会变成object","children":[]},{"level":3,"title":"4、JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；  会抛弃对象的constructor,所有的构造函数会指向Object","slug":"_4、json-stringify-只能序列化对象的可枚举的自有属性-例如-如果obj中的对象是有构造函数生成的-则使用json-parse-json-stringify-obj-深拷贝后-会丢弃对象的constructor-会抛弃对象的constructor-所有的构造函数会指向object","link":"#_4、json-stringify-只能序列化对象的可枚举的自有属性-例如-如果obj中的对象是有构造函数生成的-则使用json-parse-json-stringify-obj-深拷贝后-会丢弃对象的constructor-会抛弃对象的constructor-所有的构造函数会指向object","children":[]}]}],"git":{"updatedTime":1724247277000,"contributors":[{"name":"前端架构师","email":"62106726+qdleader@users.noreply.github.com","commits":1}]},"filePathRelative":"前端面试/js类/其他类/JSON.stringfy和JSON.parse的弊端.md"}');export{u as comp,d as data};
