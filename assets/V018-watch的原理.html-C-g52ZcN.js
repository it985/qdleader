import{_ as t,c as a,o as c,b as e}from"./app-90N25QkG.js";const h={},s=e("h1",{id:"v018-watch的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#v018-watch的原理"},[e("span",null,"V018-watch的原理")])],-1),n=e("h2",{id:"watch-的原理",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#watch-的原理"},[e("span",null,"watch 的原理")])],-1),l=e("p",null,"watch 本质上是为每个监听属性 setter 创建了一个 watcher，当被监听的属性更新时，调用传入的回调函数。常见的配置选项有 deep 和 immediate，对应原理如下",-1),o=e("p",null,"• deep：深度监听对象，为对象的每一个属性创建一个 watcher，从而确保对象的每一个属性更新时都会触发传入的回调函数。主要原因在于对象属于引用类型，单个属性的更新并不会触发对象 setter，因此引入 deep 能够很好地解决监听对象的问题。同时也会引入判断机制，确保在多个属性更新时回调函数仅触发一次，避免性能浪费。",-1),r=e("p",null,"• immediate：在初始化时直接调用回调函数，可以通过在 created 阶段手动调用回调函数实现相同的效果",-1),i=[s,n,l,o,r];function d(_,m){return c(),a("div",null,i)}const u=t(h,[["render",d],["__file","V018-watch的原理.html.vue"]]),w=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue%E7%AF%87/V018-watch%E7%9A%84%E5%8E%9F%E7%90%86.html","title":"V018-watch的原理","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"watch 的原理","slug":"watch-的原理","link":"#watch-的原理","children":[]}],"git":{"updatedTime":1724247277000,"contributors":[{"name":"前端架构师","email":"62106726+qdleader@users.noreply.github.com","commits":1}]},"filePathRelative":"前端面试/vue篇/V018-watch的原理.md"}');export{u as comp,w as data};
