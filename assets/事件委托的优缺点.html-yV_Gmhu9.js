import{_ as e,c as a,o as t,a as l}from"./app-90N25QkG.js";const s={},o=l('<h1 id="事件委托-事件代理-的原理以及优缺点是什么" tabindex="-1"><a class="header-anchor" href="#事件委托-事件代理-的原理以及优缺点是什么"><span>事件委托（事件代理）的原理以及优缺点是什么？</span></a></h1><h3 id="事件委托原理-事件冒泡机制" tabindex="-1"><a class="header-anchor" href="#事件委托原理-事件冒泡机制"><span>事件委托原理：事件冒泡机制；</span></a></h3><h2 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点：</span></a></h2><blockquote><p>1、可以大量节省内存占用，减少事件注册。比如ul上代理所有li的click事件就很不错； (a.每一个事件处理函数，都是一个对象，多一个事件处理函数，内存中就会被多占用一部分空间。如果要用事件委托，就会将所有的操作放到 js 程序里面，只对它的父级进行操作，与 dom 的操作就只需要交互一次，这样就能大大的减少与 dom 的交互次数，提高性能； 减少了内存占用, 性能更好; b.在访问 DOM 方面, 也使得 DOM 访问次数减少试想一下, 如果要为许多的 DOM 元素绑定事件, 自然需要多次访问 DOM 元素, 设置事件处理程序所需时间更长, 整个页面就绪需要的时间越多因此第二个优点是: 设置事件处理程序所需时间更少, 加快了整个页面的交互就绪时间)</p></blockquote><blockquote><p>2、可以实现当新增子对象时，无需再对其进行事件绑定，对于动态内容部分尤为适合；</p></blockquote><h2 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点：</span></a></h2><blockquote><p>事件委托的实现依靠的冒泡，因此不支持事件冒泡的事件就不适合使用事件委托。 不是所有的事件绑定都适合使用事件委托，不恰当使用反而可能导致不需要绑定事件的元素也被绑定上了事件。</p></blockquote>',7),c=[o];function n(i,r){return t(),a("div",null,c)}const d=e(s,[["render",n],["__file","事件委托的优缺点.html.vue"]]),_=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/js%E7%B1%BB/DOM%E7%B1%BB/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.html","title":"事件委托（事件代理）的原理以及优缺点是什么？","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"事件委托原理：事件冒泡机制；","slug":"事件委托原理-事件冒泡机制","link":"#事件委托原理-事件冒泡机制","children":[]},{"level":2,"title":"优点：","slug":"优点","link":"#优点","children":[]},{"level":2,"title":"缺点：","slug":"缺点","link":"#缺点","children":[]}],"git":{"updatedTime":1724247277000,"contributors":[{"name":"前端架构师","email":"62106726+qdleader@users.noreply.github.com","commits":1}]},"filePathRelative":"前端面试/js类/DOM类/事件委托的优缺点.md"}');export{d as comp,_ as data};
