import{_ as t,c as r,o,b as e}from"./app-90N25QkG.js";const n={},l=e("h1",{id:"vue3为什么要用proxy替代defineproperty",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#vue3为什么要用proxy替代defineproperty"},[e("span",null,"vue3为什么要用Proxy替代defineProperty")])],-1),s=e("p",null,"vue2 中 采用 defineProperty 来劫持整个对象，然后进行深度遍历所有属性，给每个属性添加getter和setter，实现响应式，但有以下问题",-1),a=e("blockquote",null,[e("p",null,"检测不到对象属性的添加和删除 数组API 无法监听到（ 无法监听数组基于下标的修改） 需要对每个属性进行遍历监听，如果嵌套对象，需要深层监听，造成性能问题 对 Map、Set、WeakMap 和 WeakSet 不支持；")],-1),i=e("p",null,"2、proxy： 监听是针对一个对象的，那么对于这个对象的所有操作会进入监听操作",-1),p=e("h2",{id:"总结",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#总结"},[e("span",null,"总结")])],-1),d=e("blockquote",null,[e("p",null,"Object.defineProperty 只能遍历对象属性进行劫持 Proxy 可以直接劫持整个对象，并返回一个新的对象，我们可以只操作新的对象达到响应式目的 Proxy 可以直接监听数组的变化(push、 shift、splice) Proxy 有多达13种拦截方法，不限于apply、ownkeys、deleteProperty、has等等，这个是Object.defineProperty 不具备的")],-1),c=[l,s,a,i,p,d];function _(u,h){return o(),r("div",null,c)}const f=t(n,[["render",_],["__file","vue3为什么要用Proxy替代defineProperty.html.vue"]]),P=JSON.parse('{"path":"/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/vue3%E7%AF%87/vue3%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Proxy%E6%9B%BF%E4%BB%A3defineProperty.html","title":"vue3为什么要用Proxy替代defineProperty","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"updatedTime":1724247277000,"contributors":[{"name":"前端架构师","email":"62106726+qdleader@users.noreply.github.com","commits":1}]},"filePathRelative":"前端面试/vue3篇/vue3为什么要用Proxy替代defineProperty.md"}');export{f as comp,P as data};
